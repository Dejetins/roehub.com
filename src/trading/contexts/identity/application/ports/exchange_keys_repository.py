from __future__ import annotations

from datetime import datetime
from typing import Protocol
from uuid import UUID

from trading.contexts.identity.domain.entities import ExchangeKey
from trading.shared_kernel.primitives import UserId


class ExchangeKeysRepository(Protocol):
    """
    ExchangeKeysRepository â€” storage port for identity exchange API keys v2.

    Docs:
      - docs/architecture/identity/identity-exchange-keys-storage-2fa-gate-policy-v2.md
    Related:
      - src/trading/contexts/identity/domain/entities/exchange_key.py
      - src/trading/contexts/identity/application/use_cases/create_exchange_key.py
      - src/trading/contexts/identity/adapters/outbound/persistence/postgres/
        exchange_keys_repository.py
      - migrations/postgres/0004_identity_exchange_keys_v2.sql
    """

    def create(
        self,
        *,
        key_id: UUID,
        user_id: UserId,
        exchange_name: str,
        market_type: str,
        label: str | None,
        permissions: str,
        api_key_enc: bytes,
        api_key_hash: bytes,
        api_key_last4: str,
        api_secret_enc: bytes,
        passphrase_enc: bytes | None,
        created_at: datetime,
        updated_at: datetime,
    ) -> ExchangeKey | None:
        """
        Create new active exchange key row and return persisted snapshot.

        Args:
            key_id: Deterministic identifier generated by application layer.
            user_id: Owner identity user id.
            exchange_name: Exchange literal (`binance` or `bybit`).
            market_type: Market literal (`spot` or `futures`).
            label: Optional user-defined label.
            permissions: Permission literal (`read` or `trade`).
            api_key_enc: Encrypted API key blob.
            api_key_hash: Deterministic API key hash for unique index semantics.
            api_key_last4: Deterministic API key suffix for masked API responses.
            api_secret_enc: Encrypted API secret blob.
            passphrase_enc: Optional encrypted passphrase blob.
            created_at: UTC creation timestamp.
            updated_at: UTC update timestamp.
        Returns:
            ExchangeKey | None: Persisted row or `None` when active duplicate exists.
        Assumptions:
            Implementations enforce deterministic duplicate semantics for active rows.
        Raises:
            ValueError: If adapter cannot persist or map row.
        Side Effects:
            Writes one storage record.
        """
        ...

    def list_active_for_user(self, *, user_id: UserId) -> tuple[ExchangeKey, ...]:
        """
        Return active (non-deleted) exchange keys for user in deterministic order.

        Args:
            user_id: Owner identity user id.
        Returns:
            tuple[ExchangeKey, ...]: Active keys ordered by `created_at ASC, key_id ASC`.
        Assumptions:
            Implementations exclude soft-deleted rows from result.
        Raises:
            ValueError: If adapter cannot map one or more rows.
        Side Effects:
            Reads storage records.
        """
        ...

    def soft_delete(
        self,
        *,
        user_id: UserId,
        key_id: UUID,
        deleted_at: datetime,
        updated_at: datetime,
    ) -> bool:
        """
        Soft-delete owned active key by setting delete markers.

        Args:
            user_id: Owner identity user id.
            key_id: Exchange key identifier.
            deleted_at: UTC timestamp for delete marker.
            updated_at: UTC timestamp for update marker.
        Returns:
            bool: `True` when key was deleted, `False` when key is
                missing/not-owned/already deleted.
        Assumptions:
            Delete operation does not physically remove row in v1.
        Raises:
            ValueError: If adapter cannot execute update statement.
        Side Effects:
            Writes one storage record when row is found.
        """
        ...
